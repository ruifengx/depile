<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive [`syn::parse::Parse`] for syntax tree node."><meta name="keywords" content="rust, rustlang, rust-lang, Parse"><title>Parse in structmeta - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../structmeta/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="index.html">structmeta</a></h2><div id="sidebar-vars" data-name="Parse" data-ty="derive" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Derive Macro <a href="index.html">structmeta</a>::<wbr><a class="derive" href="#">Parse</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/structmeta_derive/lib.rs.html#22" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust derive"><code>#[derive(Parse)]
{
    // Attributes available to this derive:
    #[to_tokens]
    #[parse]
}
</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive <a href="../syn/parse/trait.Parse.html" title="syn::parse::Parse"><code>syn::parse::Parse</code></a> for syntax tree node.</p>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#helper-attributes">Helper attributes</a>
<ul>
<li><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></li>
<li><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></li>
<li><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></li>
<li><a href="#parsepeek"><code>#[parse(peek)]</code></a></li>
<li><a href="#parseany"><code>#[parse(any)]</code></a></li>
<li><a href="#parseterminated"><code>#[parse(terminated)]</code></a></li>
<li><a href="#parsedump"><code>#[parse(dump)]</code></a></li>
</ul>
</li>
</ul>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<p><code>#[derive(Parse)]</code> generates an implementation of <code>Parse</code> that calls <a href="../syn/parse/trait.Parse.html#tymethod.parse"><code>Parse::parse</code></a> for each field.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">LitInt</span>, <span class="ident">LitStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">Example</span>(<span class="ident">LitInt</span>, <span class="ident">LitStr</span>);</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">syn::parse::Parse</span> <span class="kw">for</span> <span class="ident">Example</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">input</span>: <span class="ident">syn::parse::ParseStream</span>) -&gt; <span class="ident">syn::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">_0</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">_1</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">Example</span>(<span class="ident">_0</span>, <span class="ident">_1</span>));
    }
}</code></pre></div>
<p><code>#[derive(Parse)]</code> can also be specified for enum.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">LitInt</span>, <span class="ident">LitStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">Example</span> {
    <span class="ident">A</span>(<span class="ident">LitInt</span>, <span class="ident">LitInt</span>),
    <span class="ident">B</span>(<span class="ident">LitStr</span>),
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn::parse::discouraged::Speculative</span>;
<span class="kw">impl</span> <span class="ident">syn::parse::Parse</span> <span class="kw">for</span> <span class="ident">Example</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">input</span>: <span class="ident">syn::parse::ParseStream</span>) -&gt; <span class="ident">syn::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">fork</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">fork</span>();
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">value</span>) <span class="op">=</span> <span class="ident">fork</span>.<span class="ident">call</span>(<span class="op">|</span><span class="ident">input</span><span class="op">|</span> <span class="prelude-val">Ok</span>(<span class="ident">Example::A</span>(<span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>, <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))) {
            <span class="ident">input</span>.<span class="ident">advance_to</span>(<span class="kw-2">&amp;</span><span class="ident">fork</span>);
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">value</span>);
        }

        <span class="kw">let</span> <span class="ident">fork</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">fork</span>();
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">value</span>) <span class="op">=</span> <span class="ident">fork</span>.<span class="ident">call</span>(<span class="op">|</span><span class="ident">input</span><span class="op">|</span> <span class="prelude-val">Ok</span>(<span class="ident">Example::B</span>(<span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))) {
            <span class="ident">input</span>.<span class="ident">advance_to</span>(<span class="kw-2">&amp;</span><span class="ident">fork</span>);
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">value</span>);
        }

        <span class="prelude-val">Err</span>(<span class="ident">input</span>.<span class="ident">error</span>(<span class="string">&quot;parse failed.&quot;</span>))
    }
}</code></pre></div>
<h2 id="helper-attributes" class="section-header"><a href="#helper-attributes">Helper attributes</a></h2><div><table><thead><tr><th></th><th>struct</th><th>enum</th><th>varaint</th><th>field</th></tr></thead><tbody>
<tr><td><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parsepeek"><code>#[parse(peek)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parseany"><code>#[parse(any)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parseterminated"><code>#[parse(terminated)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parsedump"><code>#[parse(dump)]</code></a></td><td>✔</td><td>✔</td><td></td><td></td></tr>
</tbody></table>
</div><h3 id="to_tokens-to_tokens" class="section-header"><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;[&quot;)]</code> for a field of type <a href="../syn/token/struct.Bracket.html" title="syn::token::Bracket"><code>syn::token::Bracket</code></a>, subsequent tokens will be enclosed in <code>[]</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;]&quot;)]</code> for the field after the end of the enclosure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">token</span>, <span class="ident">LitInt</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">Example</span> {
    <span class="ident">x</span>: <span class="ident">LitInt</span>,
    <span class="attribute">#[<span class="ident">to_tokens</span>(<span class="string">&quot;[&quot;</span>)]</span>
    <span class="ident">bracket_token</span>: <span class="ident">token::Bracket</span>,
    <span class="ident">y</span>: <span class="ident">LitInt</span>,
    <span class="attribute">#[<span class="ident">to_tokens</span>(<span class="string">&quot;]&quot;</span>)]</span>
    <span class="ident">z</span>: <span class="ident">LitInt</span>,
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">syn::parse::Parse</span> <span class="kw">for</span> <span class="ident">Example</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">input</span>: <span class="ident">syn::parse::ParseStream</span>) -&gt; <span class="ident">syn::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">content</span>;
        <span class="kw">let</span> <span class="ident">bracket_token</span> <span class="op">=</span> <span class="macro">syn::bracketed!</span>(<span class="ident">content</span> <span class="kw">in</span> <span class="ident">input</span>);
        <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">content</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="self">Self</span> {
            <span class="ident">x</span>,
            <span class="ident">bracket_token</span>,
            <span class="ident">y</span>,
            <span class="ident">z</span>,
        })
    }
}</code></pre></div>
<h3 id="to_tokens-to_tokens-1" class="section-header"><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;(&quot;)]</code> for a field of type <a href="../syn/token/struct.Paren.html" title="syn::token::Paren"><code>syn::token::Paren</code></a>, subsequent tokens will be enclosed in <code>()</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;)&quot;)]</code> for the field after the end of the enclosure.</p>
<h3 id="to_tokens-to_tokens-2" class="section-header"><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;{&quot;)]</code> for a field of type <a href="../syn/token/struct.Brace.html" title="syn::token::Brace"><code>syn::token::Brace</code></a>, subsequent tokens will be enclosed in <code>{}</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;}&quot;)]</code> for the field after the end of the enclosure.</p>
<h3 id="parsepeek" class="section-header"><a href="#parsepeek"><code>#[parse(peek)]</code></a></h3>
<p>When parsing an enum, it will peek the field with this attribute set,
and if successful, will parse the variant containing the field.
If the peek succeeds, the subsequent variant will not be parsed even if the parse failed.</p>
<p>Variant where <code>#[parse(peek)]</code> is not specified will fork input and parse.</p>
<p>If the peek fails or the parsing of the forked input fails, the subsequent variant will be parsed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">LitInt</span>, <span class="ident">LitStr</span>};
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">Example</span> {
    <span class="ident">A</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span> <span class="ident">LitInt</span>, <span class="ident">LitInt</span>),
    <span class="ident">B</span>(<span class="ident">LitStr</span>),
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">syn::parse::Parse</span> <span class="kw">for</span> <span class="ident">Example</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">input</span>: <span class="ident">syn::parse::ParseStream</span>) -&gt; <span class="ident">syn::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">input</span>.<span class="ident">peek</span>(<span class="ident">LitInt</span>) {
            <span class="kw">let</span> <span class="ident">a_0</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
            <span class="kw">let</span> <span class="ident">a_1</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">Example::A</span>(<span class="ident">a_0</span>, <span class="ident">a_1</span>));
        }
        <span class="kw">let</span> <span class="ident">b_0</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="ident">Example::B</span>(<span class="ident">b_0</span>))
    }
}</code></pre></div>
<p><code>#[parse(peek)]</code> can be specified on the first three <code>TokenTree</code> for each variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">LitInt</span>, <span class="ident">LitStr</span>};
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">Example</span> {
    <span class="ident">A</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span> <span class="ident">LitInt</span>, <span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span><span class="ident">LitInt</span>, <span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span><span class="ident">LitInt</span>),
    <span class="ident">B</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span> <span class="ident">LitStr</span>),
}</code></pre></div>
<p>Since the tokens enclosed by the delimiter is treated as a single token tree, you can also specify <code>#[parse(peek)]</code> to the field with <code>#[to_tokens(&quot;]&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">token</span>, <span class="ident">LitInt</span>, <span class="ident">LitStr</span>};
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">Example</span> {
    <span class="ident">A</span> {
        <span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span>
        <span class="attribute">#[<span class="ident">to_tokens</span>(<span class="string">&quot;{&quot;</span>)]</span>
        <span class="ident">a</span>: <span class="ident">token::Brace</span>,
        <span class="ident">b</span>: <span class="ident">LitInt</span>,
        <span class="ident">c</span>: <span class="ident">LitInt</span>,
        <span class="attribute">#[<span class="ident">to_tokens</span>(<span class="string">&quot;}&quot;</span>)]</span>
        <span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span>
        <span class="ident">d</span>: <span class="ident">LitInt</span>,
    },
}</code></pre></div>
<p>To use <code>#[parse(peek)]</code> for a field that type is <code>Ident</code>, use <code>syn::Ident</code> insted of <code>proc_macro2::Ident</code>.</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">ExampleNg</span> {
    <span class="ident">A</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span> <span class="ident">proc_macro2::Ident</span>),
}</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">structmeta::Parse</span>)]</span>
<span class="kw">enum</span> <span class="ident">ExampleOk</span> {
    <span class="ident">A</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">peek</span>)]</span> <span class="ident">syn::Ident</span>),
}</code></pre></div>
<h3 id="parseany" class="section-header"><a href="#parseany"><code>#[parse(any)]</code></a></h3>
<p>When parsing <code>Ident</code>, allow values that cannot be used as identifiers, such as keywords.</p>
<p>In other words, <code>Ident::parse_any</code> and <code>Ident::peek_any</code> was generated instead of <code>Ident::parse</code> and <code>Ident::peek</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">quote::quote</span>;
<span class="kw">use</span> <span class="ident">structmeta::Parse</span>;
<span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">parse2</span>, <span class="ident">Ident</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">WithAny</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">any</span>)]</span> <span class="ident">Ident</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">WithoutAny</span>(<span class="ident">Ident</span>);

<span class="macro">assert_eq!</span>(<span class="ident">parse2</span>::<span class="op">&lt;</span><span class="ident">WithAny</span><span class="op">&gt;</span>(<span class="macro">quote!</span>(<span class="self">self</span>)).<span class="ident">is_ok</span>(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">parse2</span>::<span class="op">&lt;</span><span class="ident">WithoutAny</span><span class="op">&gt;</span>(<span class="macro">quote!</span>(<span class="self">self</span>)).<span class="ident">is_ok</span>(), <span class="bool-val">false</span>);</code></pre></div>
<h3 id="parseterminated" class="section-header"><a href="#parseterminated"><code>#[parse(terminated)]</code></a></h3>
<p>Use <a href="../syn/punctuated/struct.Punctuated.html#method.parse_terminated"><code>Punctuated::parse_terminated</code></a> to parse.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">quote::quote</span>;
<span class="kw">use</span> <span class="ident">structmeta::Parse</span>;
<span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">parse2</span>, <span class="ident">punctuated::Punctuated</span>, <span class="ident">Ident</span>, <span class="ident">Token</span>};
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">Example</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">terminated</span>)]</span> <span class="ident">Punctuated</span><span class="op">&lt;</span><span class="ident">Ident</span>, <span class="macro">Token!</span>[,]<span class="op">&gt;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">parse2</span>::<span class="op">&lt;</span><span class="ident">Example</span><span class="op">&gt;</span>(<span class="macro">quote!</span>(<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">c</span>)).<span class="ident">is_ok</span>(), <span class="bool-val">true</span>);</code></pre></div>
<p><code>terminated</code> can also be used with <code>any</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">quote::quote</span>;
<span class="kw">use</span> <span class="ident">structmeta::Parse</span>;
<span class="kw">use</span> <span class="ident">syn</span>::{<span class="ident">parse2</span>, <span class="ident">punctuated::Punctuated</span>, <span class="ident">Ident</span>, <span class="ident">Token</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">WithAny</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">terminated</span>, <span class="ident">any</span>)]</span> <span class="ident">Punctuated</span><span class="op">&lt;</span><span class="ident">Ident</span>, <span class="macro">Token!</span>[,]<span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Parse</span>)]</span>
<span class="kw">struct</span> <span class="ident">WithoutAny</span>(<span class="attribute">#[<span class="ident">parse</span>(<span class="ident">terminated</span>)]</span> <span class="ident">Punctuated</span><span class="op">&lt;</span><span class="ident">Ident</span>, <span class="macro">Token!</span>[,]<span class="op">&gt;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">parse2</span>::<span class="op">&lt;</span><span class="ident">WithAny</span><span class="op">&gt;</span>(<span class="macro">quote!</span>(<span class="self">self</span>, <span class="self">self</span>)).<span class="ident">is_ok</span>(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">parse2</span>::<span class="op">&lt;</span><span class="ident">WithoutAny</span><span class="op">&gt;</span>(<span class="macro">quote!</span>(<span class="self">self</span>, <span class="self">self</span>)).<span class="ident">is_ok</span>(), <span class="bool-val">false</span>);</code></pre></div>
<h3 id="parsedump" class="section-header"><a href="#parsedump"><code>#[parse(dump)]</code></a></h3>
<p>Causes a compile error and outputs the code generated by <code>#[derive(Parse)]</code> as an error message.</p>
</div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="structmeta" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
</body></html>