<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides derive macro `Display` and `FromStr`. These macros use common helper attributes to specify the format."><meta name="keywords" content="rust, rustlang, rust-lang, parse_display"><title>parse_display - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../parse_display/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate parse_display</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.5.3</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all parse_display's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><div id="sidebar-vars" data-name="parse_display" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">parse_display</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/parse_display/lib.rs.html#3-735" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides derive macro <code>Display</code> and <code>FromStr</code>.
These macros use common helper attributes to specify the format.</p>
<h3 id="install" class="section-header"><a href="#install">Install</a></h3>
<p>Add this to your Cargo.toml:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
parse-display = &quot;0.5.3&quot;</code></pre></div><h3 id="example" class="section-header"><a href="#example">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a}-{b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="ident">b</span>: <span class="ident">u32</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }.<span class="ident">to_string</span>(), <span class="string">&quot;10-20&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10-20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }));


<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;snake_case&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span>,
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var_a&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;var_a&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));</code></pre></div>
<h3 id="helper-attributes" class="section-header"><a href="#helper-attributes">Helper attributes</a></h3>
<p>Helper attributes can be written in the following positions.</p>
<div><table><thead><tr><th>attribute</th><th>struct</th><th>enum</th><th>variant</th><th>field</th></tr></thead><tbody>
<tr><td><a href="#display"><code>#[display(&quot;...&quot;)]</code></a></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr>
<tr><td><a href="#displaystyle--"><code>#[display(style = &quot;...&quot;)]</code></a></td><td></td><td>✔</td><td>✔</td><td></td></tr>
<tr><td><a href="#displaybound"><code>#[display(bound(...))]</code></a></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr>
<tr><td><a href="#from_strbound"><code>#[from_str(bound(...))]</code></a></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr>
<tr><td><a href="#from_strregex--"><code>#[from_str(regex = &quot;...&quot;)]</code></a></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr>
<tr><td><a href="#from_strnew--"><code>#[from_str(new = ...)]</code></a></td><td>✔</td><td></td><td>✔</td><td></td></tr>
<tr><td><a href="#from_strdefault"><code>#[from_str(default)]</code></a></td><td>✔</td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#from_strdefault_fields"><code>#[from_str(default_fields(...))]</code></a></td><td>✔</td><td>✔</td><td>✔</td><td></td></tr>
</tbody></table>
</div>
<p><code>#[derive(Display)]</code> use <code>#[display]</code>.
<code>#[derive(FromStr)]</code> use both <code>#[display]</code> and <code>#[from_str]</code>.</p>
<p><code>key = value</code> style parameter can be specified only once for each key.
<code>key(value1, value2, ...)</code> style parameter can be specified multiple times.</p>
<h3 id="display" class="section-header"><a href="#display"><code>#[display(&quot;...&quot;)]</code></a></h3>
<p>Specifies the format using a syntax similar to <code>std::format!()</code>.
However, unlike <code>std::format!()</code>, field name is specified in <code>{}</code>.</p>
<h4 id="struct-format" class="section-header"><a href="#struct-format">Struct format</a></h4>
<p>By writing <code>#[display(&quot;..&quot;)]</code>, you can specify the format used by <code>Display</code> and <code>FromStr</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a}-{b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="ident">b</span>: <span class="ident">u32</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }.<span class="ident">to_string</span>(), <span class="string">&quot;10-20&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10-20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{0}+{1}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyTuple</span>(<span class="ident">u32</span>, <span class="ident">u32</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyTuple</span>(<span class="number">10</span>, <span class="number">20</span>).<span class="ident">to_string</span>(), <span class="string">&quot;10+20&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10+20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyTuple</span>(<span class="number">10</span>, <span class="number">20</span>)));</code></pre></div>
<h4 id="newtype-pattern" class="section-header"><a href="#newtype-pattern">Newtype pattern</a></h4>
<p>If the struct has only one field, the format can be omitted.
In this case, the only field is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">NewType</span>(<span class="ident">u32</span>);
<span class="macro">assert_eq!</span>(<span class="ident">NewType</span>(<span class="number">10</span>).<span class="ident">to_string</span>(), <span class="string">&quot;10&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">NewType</span>(<span class="number">10</span>)));</code></pre></div>
<h4 id="enum-format" class="section-header"><a href="#enum-format">Enum format</a></h4>
<p>In enum, you can specify the format for each variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;aaa&quot;</span>)]</span>
  <span class="ident">VarA</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;bbb&quot;</span>)]</span>
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;aaa&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarB</span>.<span class="ident">to_string</span>(), <span class="string">&quot;bbb&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;aaa&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bbb&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span>));</code></pre></div>
<p>In enum format, <code>{}</code> means variant name.
Variant name style (e.g. snake_case, camelCase, …) can be specified by <a href="#displaystyle--"><code>#[from_str(style = &quot;...&quot;)]</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;aaa-{}&quot;</span>)]</span>
  <span class="ident">VarA</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;bbb-{}&quot;</span>)]</span>
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;aaa-VarA&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarB</span>.<span class="ident">to_string</span>(), <span class="string">&quot;bbb-VarB&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;aaa-VarA&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bbb-VarB&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span>));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;snake_case&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnumSnake</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{}&quot;</span>)]</span>
  <span class="ident">VarA</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnumSnake::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var_a&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;var_a&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnumSnake::VarA</span>));</code></pre></div>
<p>By writing a format on enum instead of variant, you can specify the format common to multiple variants.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;xxx-{}&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span>,
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;xxx-VarA&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarB</span>.<span class="ident">to_string</span>(), <span class="string">&quot;xxx-VarB&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;xxx-VarA&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;xxx-VarB&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span>));</code></pre></div>
<h4 id="unit-variants" class="section-header"><a href="#unit-variants">Unit variants</a></h4>
<p>If all variants has no field, format can be omitted.
In this case, variant name is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span>,
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VarA&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarB</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VarB&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;VarA&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;VarB&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span>));</code></pre></div>
<h4 id="field-format" class="section-header"><a href="#field-format">Field format</a></h4>
<p>You can specify the format of the field.
In field format, <code>{}</code> means the field itself.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a}, {b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;a is {}&quot;</span>)]</span>
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;b is {}&quot;</span>)]</span>
  <span class="ident">b</span>: <span class="ident">u32</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }.<span class="ident">to_string</span>(), <span class="string">&quot;a is 10, b is 20&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;a is 10, b is 20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{0}, {1}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyTuple</span>(<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;first is {}&quot;</span>)]</span> <span class="ident">u32</span>, <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;next is {}&quot;</span>)]</span> <span class="ident">u32</span>);
<span class="macro">assert_eq!</span>(<span class="ident">MyTuple</span>(<span class="number">10</span>, <span class="number">20</span>).<span class="ident">to_string</span>(), <span class="string">&quot;first is 10, next is 20&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;first is 10, next is 20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyTuple</span>(<span class="number">10</span>, <span class="number">20</span>)));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;this is A {0}&quot;</span>)]</span>
  <span class="ident">VarA</span>(<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;___{}___&quot;</span>)]</span> <span class="ident">u32</span>),
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>(<span class="number">10</span>).<span class="ident">to_string</span>(), <span class="string">&quot;this is A ___10___&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;this is A ___10___&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>(<span class="number">10</span>)));</code></pre></div>
<h4 id="display-field-chain" class="section-header"><a href="#display-field-chain">Display field chain</a></h4>
<p>You can use “field chain”, e.g. <code>{x.a}</code> .</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PartialEq</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="ident">b</span>: <span class="ident">u32</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">Display</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{x.a}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">FieldChain</span> {
  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">default</span>)]</span>
  <span class="ident">x</span>: <span class="ident">MyStruct</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">FieldChain</span> { <span class="ident">x</span>:<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> } }.<span class="ident">to_string</span>(), <span class="string">&quot;10&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">FieldChain</span> { <span class="ident">x</span>:<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">0</span> } }));</code></pre></div>
<p>When using “field chain”, you need to use <a href="#from_strdefault"><code>#[from_str(default)]</code></a> to implement <code>FromStr</code>.</p>
<h4 id="format-parameter" class="section-header"><a href="#format-parameter">Format parameter</a></h4>
<p>Like <code>std::format!()</code>, format parameter can be specified.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a:&gt;04}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">WithFormatParameter</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">WithFormatParameter</span> { <span class="ident">a</span>:<span class="number">5</span> }.<span class="ident">to_string</span>(), <span class="string">&quot;0005&quot;</span>);</code></pre></div>
<h3 id="displaystyle--" class="section-header"><a href="#displaystyle--"><code>#[display(style = &quot;...&quot;)]</code></a></h3>
<p>By writing <code>#[display(style = &quot;...&quot;)]</code>, you can specify the variant name style.
The following styles are available.</p>
<ul>
<li><code>none</code></li>
<li><code>lowercase</code></li>
<li><code>UPPERCASE</code></li>
<li><code>snake_case</code></li>
<li><code>SNAKE_CASE</code></li>
<li><code>camelCase</code></li>
<li><code>CamelCase</code></li>
<li><code>kebab-case</code></li>
<li><code>KEBAB-CASE</code></li>
<li><code>Title Case</code></li>
<li><code>Title case</code></li>
<li><code>title case</code></li>
<li><code>TITLE CASE</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;snake_case&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span>,
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">MyEnum::VarA</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var_a&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;var_a&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">StyleExample</span> {
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;none&quot;</span>)]</span>
  <span class="ident">VarA1</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;none&quot;</span>)]</span>
  <span class="ident">varA2</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;lowercase&quot;</span>)]</span>
  <span class="ident">VarB</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;UPPERCASE&quot;</span>)]</span>
  <span class="ident">VarC</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;snake_case&quot;</span>)]</span>
  <span class="ident">VarD</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;SNAKE_CASE&quot;</span>)]</span>
  <span class="ident">VarE</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;camelCase&quot;</span>)]</span>
  <span class="ident">VarF</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;CamelCase&quot;</span>)]</span>
  <span class="ident">VarG1</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;CamelCase&quot;</span>)]</span>
  <span class="ident">varG2</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;kebab-case&quot;</span>)]</span>
  <span class="ident">VarH</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;KEBAB-CASE&quot;</span>)]</span>
  <span class="ident">VarI</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;Title Case&quot;</span>)]</span>
  <span class="ident">VarJ</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;Title case&quot;</span>)]</span>
  <span class="ident">VarK</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;title case&quot;</span>)]</span>
  <span class="ident">VarL</span>,
  <span class="attribute">#[<span class="ident">display</span>(<span class="ident">style</span> <span class="op">=</span> <span class="string">&quot;TITLE CASE&quot;</span>)]</span>
  <span class="ident">VarM</span>,
}
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarA1</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VarA1&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::varA2</span>.<span class="ident">to_string</span>(), <span class="string">&quot;varA2&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarB</span>.<span class="ident">to_string</span>(), <span class="string">&quot;varb&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarC</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VARC&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarD</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var_d&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarE</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VAR_E&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarF</span>.<span class="ident">to_string</span>(), <span class="string">&quot;varF&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarG1</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VarG1&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::varG2</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VarG2&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarH</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var-h&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarI</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VAR-I&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarJ</span>.<span class="ident">to_string</span>(), <span class="string">&quot;Var J&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarK</span>.<span class="ident">to_string</span>(), <span class="string">&quot;Var k&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarL</span>.<span class="ident">to_string</span>(), <span class="string">&quot;var l&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">StyleExample::VarM</span>.<span class="ident">to_string</span>(), <span class="string">&quot;VAR M&quot;</span>);</code></pre></div>
<h3 id="displaybound" class="section-header"><a href="#displaybound"><code>#[display(bound(...))]</code></a></h3>
<p>By default, the type of field used in the format is added to the trait bound.</p>
<p>This behavior causes a compile error if you use fields of non public type in public struct.</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="attribute">#![<span class="ident">deny</span>(<span class="ident">private_in_public</span>)]</span>
<span class="kw">use</span> <span class="ident">parse_display::Display</span>;

<span class="comment">// private type `Inner&lt;T&gt;` in public interface (error E0446)</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);</code></pre></div>
<p>By writing <code>#[display(bound(...))]</code>, you can override the default behavior.</p>
<h4 id="specify-trait-bound-type" class="section-header"><a href="#specify-trait-bound-type">Specify trait bound type</a></h4>
<p>By specifying the type, you can specify the type that need to implement <code>Display</code> and <code>FromStr</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::{<span class="ident">Display</span>, <span class="ident">FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">bound</span>(<span class="ident">T</span>))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>)).<span class="ident">to_string</span>(), <span class="string">&quot;10&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>))));</code></pre></div>
<h4 id="specify-where-predicate" class="section-header"><a href="#specify-where-predicate">Specify where predicate</a></h4>
<p>You can also specify the where predicate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::Display</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">bound</span>(<span class="ident">T</span> : <span class="ident">std::fmt::Debug</span>))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{0:?}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>)).<span class="ident">to_string</span>(), <span class="string">&quot;10&quot;</span>);</code></pre></div>
<h4 id="no-trait-bounds" class="section-header"><a href="#no-trait-bounds">No trait bounds</a></h4>
<p>You can also remove all trait bounds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::Display</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">bound</span>())]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;ABC&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>)).<span class="ident">to_string</span>(), <span class="string">&quot;ABC&quot;</span>);</code></pre></div>
<h4 id="default-trait-bounds" class="section-header"><a href="#default-trait-bounds">Default trait bounds</a></h4>
<p><code>..</code> means default (automatically generated) trait bounds.</p>
<p>The following example specifies <code>T1</code> as a trait bound in addition to the default trait bound <code>T2</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::Display</span>;

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{0.0}, {1}&quot;</span>, <span class="ident">bound</span>(<span class="ident">T1</span>, ..))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T1</span>, <span class="ident">T2</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T1</span><span class="op">&gt;</span>, <span class="ident">T2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>), <span class="number">20</span>).<span class="ident">to_string</span>(), <span class="string">&quot;10, 20&quot;</span>);</code></pre></div>
<h3 id="from_strbound" class="section-header"><a href="#from_strbound"><code>#[from_str(bound(...))]</code></a></h3>
<p>You can use a different trait bound for <code>Display</code> and <code>FromStr</code> by specifying both <code>#[display(bound(...))]</code> and <code>#[from_str(bound(...))]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">fmt::Display</span>, <span class="ident">str::FromStr</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="ident">bound</span>(<span class="string">&quot;T : Display&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">bound</span>(<span class="string">&quot;T : FromStr&quot;</span>))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Outer</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Display</span>, <span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Inner</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">T</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>)).<span class="ident">to_string</span>(), <span class="string">&quot;10&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">Outer</span>(<span class="ident">Inner</span>(<span class="number">10</span>))));</code></pre></div>
<h3 id="from_strnew--" class="section-header"><a href="#from_strnew--"><code>#[from_str(new = ...)]</code></a></h3>
<p>If <code>#[from_str(new = ...)]</code> is specified, the value will be initialized with the specified expression instead of the constructor.</p>
<p>The expression must return a value that implement <a href="trait.IntoResult.html" title="IntoResult"><code>IntoResult</code></a> (e.g. <code>Self</code>, <code>Option&lt;Self&gt;</code>, <code>Result&lt;Self, E&gt;</code>).</p>
<p>In the expression, you can use a variable with the same name as the field name.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">new</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::new</span>(<span class="ident">value</span>))]</span>
<span class="kw">struct</span> <span class="ident">MyNonZeroUSize</span> {
    <span class="ident">value</span>: <span class="ident">usize</span>,
}

<span class="kw">impl</span> <span class="ident">MyNonZeroUSize</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">value</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">value</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="self">Self</span> { <span class="ident">value</span> })
        }
    }
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;1&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyNonZeroUSize</span> { <span class="ident">value</span>: <span class="number">1</span> }));
<span class="macro">assert_eq!</span>(<span class="string">&quot;0&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">MyNonZeroUSize</span><span class="op">&gt;</span>().<span class="ident">is_err</span>(), <span class="bool-val">true</span>);</code></pre></div>
<p>In tuple struct, variables are named with a leading underscore and their index. (e.g. <code>_0</code>, <code>_1</code>).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">new</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::new</span>(<span class="ident">_0</span>))]</span>
<span class="kw">struct</span> <span class="ident">MyNonZeroUSize</span>(<span class="ident">usize</span>);

<span class="kw">impl</span> <span class="ident">MyNonZeroUSize</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">value</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">value</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="self">Self</span>(<span class="ident">value</span>))
        }
    }
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;1&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyNonZeroUSize</span>(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;0&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">MyNonZeroUSize</span><span class="op">&gt;</span>().<span class="ident">is_err</span>(), <span class="bool-val">true</span>);</code></pre></div>
<h3 id="from_strregex--" class="section-header"><a href="#from_strregex--"><code>#[from_str(regex = &quot;...&quot;)]</code></a></h3>
<p>Specify the format of the string to be input with <code>FromStr</code>.
<code>#[display(&quot;...&quot;)]</code> is ignored, when this attribute is specified.</p>
<h4 id="capture-name" class="section-header"><a href="#capture-name">Capture name</a></h4>
<p>The capture name corresponds to the field name.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;(?P&lt;a&gt;[0-9]+)__(?P&lt;b&gt;[0-9]+)&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u8</span>,
  <span class="ident">b</span>: <span class="ident">u8</span>,
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;10__20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }));</code></pre></div>
<h4 id="field-regex" class="section-header"><a href="#field-regex">Field regex</a></h4>
<p>Set <code>#[display(&quot;...&quot;)]</code> to struct and set <code>#[from_str(regex = &quot;...&quot;)]</code> to field, regex is used in the position where field name is specified in <code>#[display(&quot;...&quot;)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a}__{b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;[0-9]+&quot;</span>)]</span>
  <span class="ident">a</span>: <span class="ident">u8</span>,

  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;[0-9]+&quot;</span>)]</span>
  <span class="ident">b</span>: <span class="ident">u8</span>,
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;10__20&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">20</span> }));</code></pre></div>
<p>If <code>#[from_str(regex = &quot;...&quot;)]</code> is not set to field ,
it operates in the same way as when <code>#[from_str(regex = &quot;.*?&quot;)]</code> is set.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{a}{b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">String</span>,
  <span class="ident">b</span>: <span class="ident">String</span>,
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;abcdef&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="string">&quot;&quot;</span>.<span class="ident">into</span>(), <span class="ident">b</span>:<span class="string">&quot;abcdef&quot;</span>.<span class="ident">into</span>() }));</code></pre></div>
<h4 id="variant-name" class="section-header"><a href="#variant-name">Variant name</a></h4>
<p>In the regex specified for enum or variant, empty name capture means variant name.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;___(?P&lt;&gt;)___&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span>,

  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;xxx(?P&lt;&gt;)xxx&quot;</span>)]</span>
  <span class="ident">VarB</span>,
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;___VarA___&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;xxxVarBxxx&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span>));</code></pre></div>
<h4 id="regex-field-chain" class="section-header"><a href="#regex-field-chain">Regex field chain</a></h4>
<p>You can use “field chain” in regex.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PartialEq</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">regex</span> <span class="op">=</span> <span class="string">&quot;___(?P&lt;x.a&gt;[0-9]+)&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">FieldChain</span> {
  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">default</span>)]</span>
  <span class="ident">x</span>: <span class="ident">MyStruct</span>,
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;___10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">FieldChain</span> { <span class="ident">x</span>:<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">10</span> } }));</code></pre></div>
<p>When using “field chain”, you need to use <a href="#from_strdefault"><code>#[from_str(default)]</code></a>.</p>
<h3 id="from_strdefault" class="section-header"><a href="#from_strdefault"><code>#[from_str(default)]</code></a></h3>
<p>If this attribute is specified, the default value is used for fields not included in the input.</p>
<p>If an attribute is specified for struct, the struct’s default value is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{b}&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">default</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="ident">b</span>: <span class="ident">u32</span>,
}

<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">MyStruct</span> {
  <span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
    <span class="self">Self</span> { <span class="ident">a</span>:<span class="number">99</span>, <span class="ident">b</span>:<span class="number">99</span> }
  }
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">99</span>, <span class="ident">b</span>:<span class="number">10</span> }));</code></pre></div>
<p>If an attribute is specified for field, the field type’s default value is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{b}&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">default</span>)]</span>
  <span class="ident">a</span>: <span class="ident">u32</span>,
  <span class="ident">b</span>: <span class="ident">u32</span>,
}

<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">MyStruct</span> {
  <span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
    <span class="self">Self</span> { <span class="ident">a</span>:<span class="number">99</span>, <span class="ident">b</span>:<span class="number">99</span> }
  }
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyStruct</span> { <span class="ident">a</span>:<span class="number">0</span>, <span class="ident">b</span>:<span class="number">10</span> }));</code></pre></div>
<h3 id="from_strdefault_fields" class="section-header"><a href="#from_strdefault_fields"><code>#[from_str(default_fields(...))]</code></a></h3>
<p>You can use <code>#[from_str(default_fields(...))]</code> if you want to set default values for the same-named fields of multiple variants.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_display::FromStr</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">FromStr</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">display</span>(<span class="string">&quot;{}-{a}&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">from_str</span>(<span class="ident">default_fields</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))]</span>
<span class="kw">enum</span> <span class="ident">MyEnum</span> {
  <span class="ident">VarA</span> { <span class="ident">a</span>:<span class="ident">u8</span>, <span class="ident">b</span>:<span class="ident">u8</span>, <span class="ident">c</span>:<span class="ident">u8</span> },
  <span class="ident">VarB</span> { <span class="ident">a</span>:<span class="ident">u8</span>, <span class="ident">b</span>:<span class="ident">u8</span>, <span class="ident">c</span>:<span class="ident">u8</span> },
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;VarA-10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarA</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">0</span>, <span class="ident">c</span>:<span class="number">0</span> }));
<span class="macro">assert_eq!</span>(<span class="string">&quot;VarB-10&quot;</span>.<span class="ident">parse</span>(), <span class="prelude-val">Ok</span>(<span class="ident">MyEnum::VarB</span> { <span class="ident">a</span>:<span class="number">10</span>, <span class="ident">b</span>:<span class="number">0</span>, <span class="ident">c</span>:<span class="number">0</span> }));</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="helpers/index.html" title="parse_display::helpers mod">helpers</a></div><div class="item-right docblock-short"></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ParseError.html" title="parse_display::ParseError struct">ParseError</a></div><div class="item-right docblock-short"></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoResult.html" title="parse_display::IntoResult trait">IntoResult</a></div><div class="item-right docblock-short"></div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Display.html" title="parse_display::Display derive">Display</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.FromStr.html" title="parse_display::FromStr derive">FromStr</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="parse_display" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
</body></html>